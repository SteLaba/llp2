global exit

global print_char
global print_newline
global print_string
global print_error
global print_uint
global print_int

global parse_uint
global parse_int

global read_char
global read_word

global string_equals
global string_copy
global string_length
 
; Принимает код возврата и завершает текущий процесс
exit: 
    mov rax, 60           ;syscall номер (60 - exit)
    syscall 

; Принимает указатель на нуль-терминированную строку, возвращает её длину
string_length:
    xor rax, rax          ;обнуляем rax, в нем может находиться любое число
.loop:      
    cmp byte[rdi+rax], 0  ;проверяем на нуль-терминатор
    je .end               ;заканчиваем цикл если получили нуль-терминатор
    inc rax               ;увеличиваем rax на 1
    jmp .loop             ;цикл
.end:
    ret                   ;наша функция возвращает длину стринга в rax

; Принимает указатель на нуль-терминированную строку, выводит её в stdout
print_string:
    call string_length    ;у нас в rax тепер длина нашей строки
    mov rdx, rax          ;надо прочитать байтов число которых в rax
    mov rax, 1            ;syscall номер (1 - write)
    mov rsi, rdi          ;читать стринг с адреса который в rdi
    mov rdi, 1            ;писать в stdout
    syscall
    ret

; Принимает указатель на нуль - терминированную строку, выводит её в stderr
print_error:
    call string_length    ;у нас в rax тепер длина нашей строки
    mov rdx, rax          ;надо прочитать байтов число которых в rax
    mov rax, 1            ;syscall номер (1 - write)
    mov rsi, rdi          ;читать стринг с адреса который в rdi
    mov rdi, 2            ;писать в stderr
    syscall
    ret

; Принимает код символа и выводит его в stdout
print_char:
    push rdi              ;сохраняем содержимое rdi в стеке
    mov rdi, rsp          ;сохраняем адрес вершины стека в rdi
    call print_string     ;печатаем наш символ
    pop rdi               ;возвращаем значение из стека чтобы стек опять указывал на 
                          ;адрес возврата из функции
    ret

; Переводит строку (выводит символ с кодом 0xA)
print_newline:
    mov rdi, 10           ;ASCII код символа перевода строки
    call print_char       ;печатаем наш символ
    ret

; Выводит беззнаковое 8-байтовое число в десятичном формате 
; Совет: выделите место в стеке и храните та:м результаты деления
; Не забудьте перевести цифры в их ASCII коды.
print_uint:
    mov rax, rdi          ;число в аккумуляторе
    push rbx              ;будем использовать callee регистр, сохраняем его значение
    mov rbx, 10           ;для деления используем 10, так как 10-ая СС
    mov rdi, rsp          ;верхний элемент стека в rdi
    push 0                ;нуль-терминатор, стек уменьшиться на 8
    dec rdi               ;уменьшаем rdi на 1, теперь он указывает на байт в котором 0
    sub rsp, 13           ;выделяем в стеке допольнительных 13 ячеек для записи uint
.loop:
    xor rdx, rdx          ;обнуляем rdx, в нем будет хранится остаток нашего деления
    div rbx               ;деление с 10, оcтаток в rdx, результат в rax
    add rdx, 0x30         ;добавляем 0x30, чтобы получить ASCII код нашей цифры
    dec rdi               ;уменьшаем значение rdi
    mov [rdi], dl         ;в ячейку памяти соответствующую нашему адресу который в 
                          ;rdi записиваем младший байт в котором ASCII код нашей цифры
    test rax, rax         ;провераем закончились ли цифры
    jne .loop             ;если нет - цикл
    call print_string     ;печатаем наше число
    add rsp, 21           ;возвращаем наш стек у превосходное состояние
                          ;8 для нуль-терминатора и 13 для остальных цифр
    pop rbx               ;возвращаем в превосходное состояние наш callee регистр
    ret

; Выводит знаковое 8-байтовое число в десятичном формате 
print_int:
    cmp rdi, 0            ;устанавливаем признаки состояния
    jge .print            ;если установлен 0 в бите SF, число положительное и просто
                          ;печатаем его
    push rdi              ;cохраняем наше число
    mov rdi, 0x2D         ;загружаем ASCII код символа '-'
    call print_char       ;печатаем символ '-' перед нашим числом
    pop rdi               ;возвращаем наше число в rdi
    neg rdi               ;получаем число противоположное нашему
.print:
    call print_uint       ;печатаем число
    ret

; Принимает два указателя на нуль-терминированные строки, возвращает 1 если они равны, 0 иначе
string_equals:
    call string_length     ;вычисляем длину строки 1. строки
    mov rcx, rax           ;сохраняем длину 1. строки в rcx
    xchg rdi, rsi          ;обмен значениями регистров
    call string_length     ;вычисляем длину строки 2. строки
    cmp rax, rcx           ;проверяем равны ли длины строк
    jne .false             ;если длины разные строки не одинаковые
.loop:
    dec rcx                ;уменьшаем длину строки
    mov rax, [rdi+rcx]     ;сохраняем значение последнего символа в rax
    cmp al, [rsi+rcx]      ;cравниваем коды символов
    jne .false             ;ecли коды не равны строки не одинаковые
    cmp rcx, 0             ;проверяем если длина строки равна 0
    jg .loop               ;если нет - цикл
    mov rax, 1             ;в аккумулятор 1 так как строки равны  
    ret                 
.false:
    xor rax, rax           ;обнуливаем аккумулятор
    ret

; Читает один символ из stdin и возвращает его. Возвращает 0 если достигнут конец потока
read_char:
    xor rax, rax           ;syscall номер (0 - read)
    xor rdi, rdi           ;читать из stdin
    push 0                 ;выделяем место в стеке для нашего символа
    mov rsi, rsp           ;адрес нашего символа в rsi
    mov rdx, 1             ;число байтов которых надо прочитать равно 1
    syscall                 
    pop rax                ;прочитанный символ в аккумулятор
    ret 

; Принимает: адрес начала буфера, размер буфера
; Читает в буфер слово из stdin, пропуская пробельные символы в начале, .
; Пробельные символы это пробел 0x20, табуляция 0x9 и перевод строки 0xA.
; Останавливается и возвращает 0 если слово слишком большое для буфера
; При успехе возвращает адрес буфера в rax, длину слова в rdx.
; При неудаче возвращает 0 в rax
; Эта функция должна дописывать к слову нуль-терминатор

read_word:
    xor rcx, rcx            ;обнуливаем счетчик циклов
.loop:
    push rdi                ;сохраняем значения регистров rdi и rsi потому что
    push rsi                ;их содержимое меняет функция read_char, а rcx меняет
    push rcx                ;syscall в функции read_char
    call read_char          ;читаем наш символ в rax 
    pop rcx                 ;возвращаем значения регистров
    pop rsi
    pop rdi
    cmp rax, 0x20           ;проверяем равен ли наш символ пробелу
    je .check_ws            ;если равен то переходим на проверку если этот символ в начале
    cmp rax, 0x9            ;проверка на табуляцию
    je .check_ws            ;если равно переход на проверку 
    cmp rax, 0xA            ;проверка на перевод строки
    je .check_ws            ;если равно переход на проверку
    cmp rax, 0x0            ;проверяем на конец ввода
    je .end                 ;переходим к концу функции  
    mov [rdi+rcx], rax      ;прочитанный символ записиваем в буфер
    inc rcx                 ;увеличиваем счетчик циклов на 1
    cmp rcx, rsi            ;сравниваем счетчик циклов и длину
    jl .loop                ;если меньше - цикл, если больше продолжаем
    xor rax, rax            ;обнуливаем rax
    xor rdx, rdx            ;обнуливаем rdx
    ret                 
.check_ws:
    test rcx, rcx           ;проверяем если пробел в начале
    jz .loop                ;eсли да то зацикливаемся
.end:
    mov byte[rdi+rcx], 0    ;добавляем нуль терминатор к концу слова
    mov rax, rdi            ;адрес буфера в rax
    mov rdx, rcx            ;длина буфера в rdx
    ret


; Принимает указатель на строку, пытается
; прочитать из её начала беззнаковое число.
; Возвращает в rax: число, rdx : его длину в символах
; rdx = 0 если число прочитать не удалось
parse_uint:
    push rbx                ;будем использовать callee регистри,         
    push r12                ;сохраняем их значения    
    mov rbx, 10             ;для умножения используем 10, так как 10-ая СС
    xor rcx, rcx            ;обнуливаем регистри rcx и rax
    xor rax, rax
.loop:
    mov r12, [rdi+rcx]      ;символ читаем в r12
    and r12, 0xff           ;маскируем число с 0xff
    cmp r12b, 0             ;проверяем на нуль терминатор
    je .end                 ;если найден функция закончится
    cmp r12b, 0x30          ;проверяем если наш символ явлется цифрой так что
    jb .end                 ;проверяем находится ли наше число в диапазоне
    cmp r12b, 0x39          ;0x30-0x39, в котором в ASCII кодируются цифры    
    ja .end                 ;если нет фунция закончится
    mul rbx                 ;умножаем аккумулятор на 10
    sub r12b, 0x30          ;Вычитаем из символа 0x30, чтобы получить цифру
    add rax, r12            ;добавляем к аккумулятору нашу цифру
    inc rcx                 ;увеличиваем rcx, который трактуется как длина строки
    jmp .loop
.end:
    mov rdx, rcx            ;длину строки записиваем в rdx
    pop r12                 ;воостанавливаем наши callee регистры
    pop rbx
    ret

; Принимает указатель на строку, пытается
; прочитать из её начала знаковое число.
; Если есть знак, пробелы между ним и числом не разрешены.
; Возвращает в rax: число, rdx : его длину в символах (включая знак, если он был) 
; rdx = 0 если число прочитать не удалось
parse_int:
    push rbx                ;будем использовать callee регистр
    mov rbx, [rdi]          ;первый символ в rbx
    and rbx, 0xff           ;маскируем число с 0xff
    cmp bl, 0x2D            ;сравниваем код в rbx с ASCII кодом символа '-'
    je .neg                 ;если первый символ равен '-', переходим к парсингу отрчисл
    call parse_uint         ;пытаемся парсить число, которое без начального символа -
    jmp .end                 
.neg:  
    inc rdi                 ;увеличиваем указатель на строку на 1, чтобы перешагнуть '-'
    call parse_uint         ;пытаемся парсить число как беззнаковое
    test rdx, rdx           ;если rdx равно 0, число парсить не удалось
    jz .end                 ;переходим к возврату из фунции
    neg rax                 ;если rdx не равно 0, получаем противоположное число
    inc rdx                 ;от прочитаного и rdx увеличиваем на 1 потому что '-'
.end:
    pop rbx                 ;callee регистр
    ret 

; Принимает указатель на строку, указатель на буфер и длину буфера
; Копирует строку в буфер
; Возвращает длину строки если она умещается в буфер, иначе 0
string_copy:
    call string_length      ;длина строки в аккумуляторе
    inc rax                 ;увеличиваем содержимое rax на 1, из-за нуль-терминатора
    cmp rax, rdx            ;если длина строки больше длины буфера, фунция закончится
    jg .err                 ;и в rax будет 0
    xor rcx, rcx            ;обнуливаем счетчик циклов
.loop:
    mov rdx, [rdi+rcx]      ;символ строки временно в rdx
    mov [rsi+rcx], rdx      ;символ строки копируем из rdx в буфер
    inc rcx                 ;увеличиваем счетчик циклов на 1
    cmp byte[rdi+rcx], 0    ;проверяем равен ли текущий символ нуль терминатору
    jne .loop               ;если нет зацикливаемся, иначе функция закончится
    ret
.err:
    xor rax, rax            ;обнуливаем аккумулятор
    ret
